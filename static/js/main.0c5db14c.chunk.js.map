{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["channel","userId","localStorage","getItem","Math","random","toString","slice","setItem","pubnub","PubNub","publishKey","subscribeKey","uuid","keyPair","nacl","box","getAvatar","id","decrypt","userFromPublicKey","message","payload","open","Uint8Array","nonce","secretKey","naclUtil","encodeUTF8","keyToStr","key","map","val","join","reducer","state","event","action","users","messages","console","log","publicKey","newMessages","filter","msg","user","to","userFrom","text","encrypted","GiftedChat","append","styles","container","flex","display","flexDirection","height","conversationList","padding","overflowY","chat","borderWidth","borderColor","borderRightStyle","borderLeftStyle","userrec","border","fontSize","App","useReducer","appstate","dispatch","useEffect","keyArray","Array","from","setState","channels","hereNow","includeState","status","response","occupants","forEach","listener","m","presence","presenceEvent","subscribe","withPresence","addListener","unsubscribe","removeListener","sendMessage","Object","values","messagesToPublish","createdAt","userToPublicKey","randomBytes","decodeUTF8","encrypt","publish","className","style","avatar","onSend","name","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0c5db14c.chunk.js","sourcesContent":["import React, { useEffect, useReducer } from 'react';\nimport PubNub from 'pubnub';\nimport { GiftedChat, GiftedAvatar } from 'react-web-gifted-chat';\nimport nacl from 'tweetnacl'\nimport naclUtil from 'tweetnacl-util';\n\nimport './App.css';\n\nconst channel = '41ad55e8-69e7-4386-8e3d-128765e09140';\nconst userId = localStorage.getItem('userId') ||\n  Math.random().toString(10).slice(12);\nlocalStorage.setItem('userId', userId);\n\nconst pubnub = new PubNub({\n  publishKey: 'pub-c-5e44bacc-d9b4-4d11-9462-089626f7f2e6',\n  subscribeKey: 'sub-c-347badce-45ed-11ea-aea8-722f8d3d4603',\n  uuid: userId,\n});\n\nconst keyPair = nacl.box.keyPair();\n\nconst getAvatar = (id) => (`https://i.pravatar.cc/36?u=${id}`);\n\nconst encrypt = (userToPublicKey, text) => {\n  const nonce = nacl.randomBytes(24)\n  const box = nacl.box(\n    naclUtil.decodeUTF8(text),\n    nonce,\n    new Uint8Array(userToPublicKey),\n    keyPair.secretKey\n  )\n  return {\n    box: Array.from(box),\n    nonce: Array.from(nonce)\n  }\n}\n\nconst decrypt = (userFromPublicKey, message) => {\n  const payload = nacl.box.open(\n    new Uint8Array(message.box),\n    new Uint8Array(message.nonce),\n    new Uint8Array(userFromPublicKey),\n    keyPair.secretKey\n  );\n  return naclUtil.encodeUTF8(payload)\n}\n\nconst keyToStr = (key) => {\n  if (!key) {\n    return 'none';\n  }\n  return key.map(val => val.toString(16)).join('-');\n}\n\nconst reducer = (state, event) => {\n  const { action } = event;\n  const { users, messages } = state;\n  console.log('Dispatch', action);\n  if (action === 'join' || action === 'state-change' || action === 'here-now') {\n    const { uuid } = event;\n    // add/update user\n    if (uuid === userId) {\n      // Ignore myself\n      return state;\n    }\n    users[uuid] = {\n      ...users[uuid],\n      id: uuid,\n    };\n    const publicKey = event.state ? event.state.publicKey : null;\n    if (publicKey) {\n      users[uuid].publicKey = publicKey;\n    }\n    return {\n      ...state,\n      users,\n    };\n  } else if (action === 'leave' || action === 'timeout') {\n    // delete the user\n    const { uuid } = event;\n    delete users[uuid];\n    return { ...state, users };\n  } else if (action === 'incoming-messages') {\n    // Incoming messages from others\n    const newMessages = event.messages.filter(msg => {\n      // Get only messages sent to me\n      return users[msg.user.id] && // I know the sender\n        msg.to === userId; // Message is sent to me\n    }).map(msg => {\n      const userFrom = users[msg.user.id];\n      return {\n        ...msg,\n        // Decrypt the message with sender public key\n        text: decrypt(userFrom.publicKey, msg.encrypted),\n      };\n    });\n    // Append decrypted messages to the chat\n    return {\n      ...state,\n      messages: GiftedChat.append(messages, newMessages),\n    }\n  } else if (action === 'my-messages') {\n    // Append my messages to the chat\n    return {\n      ...state,\n      messages: GiftedChat.append(messages, event.messages),\n    }\n  }\n  return state;\n}\n\nfunction App() {\n  const [appstate, dispatch] = useReducer(reducer, {\n    users: {},\n    messages: [],\n  });\n  const { users, messages } = appstate;\n\n  useEffect(() => {\n  }, []);\n\n  useEffect(() => {\n    // On start, publish my public key\n    const keyArray = Array.from(keyPair.publicKey)\n    pubnub.setState({\n      channels: [channel],\n      state: {\n        publicKey: keyArray,\n      }\n    });\n\n    // On start, request participants\n    pubnub.hereNow({ channels: [channel], includeState: true },\n      (status, response) => {\n        const { occupants } = response.channels[channel];\n        occupants.forEach(user => {\n          dispatch({\n            action: 'here-now',\n            uuid: user.uuid,\n            state: {\n              publicKey: user.state ? user.state.publicKey : null,\n            }\n          });\n        })\n      }\n    );\n\n    // PubNub message and presence listener\n    const listener = {\n      message: function (m) {\n        const { message } = m;\n        message.action = 'incoming-messages'\n        dispatch(message)\n      },\n      presence: function (presenceEvent) {\n        dispatch(presenceEvent);\n      }\n    };\n\n    // On start, subscribe to PubNub events\n    pubnub.subscribe({ channels: [channel], withPresence: true });\n    pubnub.addListener(listener);\n\n    return () => {\n      pubnub.unsubscribe({ channels: [channel] });\n      pubnub.removeListener(listener);\n    };\n  }, [])\n\n  /**\n   * Send message to others\n   * @param {Array of message} newMessages - Messages to send\n   */\n  const sendMessage = (newMessages) => {\n    // Update the chat UI\n    const event = {\n      action: 'my-messages',\n      messages: newMessages,\n    }\n    dispatch(event)\n\n    // For every participant, encrypt the message and sent it \n    // via PubNub\n    Object.values(users).filter(\n      // Do not send to myself\n      user => (user.id !== userId),\n    ).forEach(user => {\n      const { publicKey } = user;\n      const messagesToPublish = newMessages.map(message => {\n        const { createdAt, text, id } = message;\n        // Encrypt the message\n        const encrypted = encrypt(publicKey, text);\n        return {\n          createdAt,\n          user: message.user,\n          encrypted,\n          id,\n          to: user.id\n        }\n      });\n      pubnub.publish({\n        channel: channel,\n        message: {\n          messages: messagesToPublish\n        }\n      });\n    });\n  };\n\n  return (\n    <div className=\"App\" style={styles.container}>\n      <div style={styles.conversationList}>\n        <div style={styles.userrec}>\n          <div style={styles.userId}>\n            <GiftedAvatar user={{\n              id: userId,\n              avatar: getAvatar(userId),\n            }} />\n            {userId}\n          </div>\n          <div style={styles.publicKey}>\n            Public key: {keyToStr(Array.from(keyPair.publicKey))}\n          </div>\n        </div>\n        <h2>Participants</h2>\n        {\n          Object.values(users).map(user => {\n            return (\n              <div key={user.id} style={styles.userrec}>\n                <div style={styles.userId}>\n                  <GiftedAvatar user={{\n                    id: user.id,\n                    avatar: getAvatar(user.id),\n                  }} />\n                  {user.id}\n                </div>\n                <div style={styles.publicKey}>\n                  Public key: {keyToStr(user.publicKey)}\n                </div>\n              </div>\n            )\n          })\n        }\n      </div>\n      <div style={styles.chat}>\n        <GiftedChat\n          messages={messages}\n          onSend={(newMessages) => sendMessage(newMessages)}\n          user={{\n            id: userId,\n            name: userId.toString(),\n            avatar: getAvatar(userId),\n          }}\n        />\n      </div>\n    </div>\n  )\n};\n\n\nconst styles = {\n  container: {\n    flex: 1,\n    display: \"flex\",\n    flexDirection: \"row\",\n    height: \"100vh\",\n  },\n  conversationList: {\n    display: 'flex',\n    flex: 1,\n    flexDirection: 'column',\n    padding: '12px',\n    overflowY: 'scroll',\n  },\n  chat: {\n    display: \"flex\",\n    flex: 3,\n    flexDirection: \"column\",\n    borderWidth: \"1px\",\n    borderColor: \"#ccc\",\n    borderRightStyle: \"solid\",\n    borderLeftStyle: \"solid\",\n  },\n  userrec: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    padding: '8px',\n    border: '1px solid #aaa',\n  },\n  userId: {\n    display: 'flex',\n    flexDirection: 'row',\n    fontSize: '16px',\n  },\n  publicKey: {\n    fontSize: '12px',\n  },\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}