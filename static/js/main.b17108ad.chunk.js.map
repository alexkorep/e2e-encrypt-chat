{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["userId","localStorage","getItem","Math","random","toString","slice","setItem","pubnub","PubNub","publishKey","subscribeKey","uuid","keyPair","nacl","box","getAvatar","id","decrypt","userFromPublicKey","message","payload","open","Uint8Array","nonce","secretKey","naclUtil","encodeUTF8","styles","container","flex","display","flexDirection","height","conversationList","padding","overflowY","chat","borderWidth","borderColor","borderRightStyle","borderLeftStyle","converationDetails","userrec","App","useState","messages","setMessages","useReducer","state","presenceEvent","action","publicKey","users","dispatchUsers","useEffect","listener","m","console","log","newMessages","filter","msg","to","user","map","encrypted","text","oldMessages","GiftedChat","append","presence","subscribe","channels","withPresence","addListener","keyArray","Array","from","setState","hereNow","includeState","status","response","occupants","forEach","unsubscribe","removeListener","sendMessage","Object","values","messagesToPublish","createdAt","userToPublicKey","randomBytes","decodeUTF8","encrypt","publish","channel","className","style","key","avatar","val","join","onSend","name","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b17108ad.chunk.js","sourcesContent":["import React, { useEffect, useState, useReducer } from 'react';\nimport PubNub from 'pubnub';\nimport { GiftedChat, GiftedAvatar } from 'react-web-gifted-chat';\nimport nacl from 'tweetnacl'\nimport naclUtil from 'tweetnacl-util';\n\nimport './App.css';\n\nconst channel = 'chat';\nconst userId = localStorage.getItem('userId') ||\n  Math.random().toString(10).slice(2);\nlocalStorage.setItem('userId', userId);\n\nconst pubnub = new PubNub({\n  publishKey: 'pub-c-5e44bacc-d9b4-4d11-9462-089626f7f2e6',\n  subscribeKey: 'sub-c-347badce-45ed-11ea-aea8-722f8d3d4603',\n  uuid: userId,\n});\n\nconst keyPair = nacl.box.keyPair();\n\nconst getAvatar = (id) => (`https://i.pravatar.cc/36?u=${id}`);\n\nconst encrypt = (userToPublicKey, text) => {\n  const nonce = nacl.randomBytes(24)\n  const box = nacl.box(\n    naclUtil.decodeUTF8(text),\n    nonce,\n    new Uint8Array(userToPublicKey),\n    keyPair.secretKey\n  )\n  return {\n    box: Array.from(box),\n    nonce: Array.from(nonce)\n  }\n}\n\nconst decrypt = (userFromPublicKey, message) => {\n  const payload = nacl.box.open(\n    new Uint8Array(message.box),\n    new Uint8Array(message.nonce),\n    new Uint8Array(userFromPublicKey),\n    keyPair.secretKey\n  );\n  return naclUtil.encodeUTF8(payload)\n}\n\nconst keyToStr = (key) => {\n  if (!key) {\n    return 'none';\n  }\n  return key.map(val => val.toString(10)).join('-');\n}\n\nfunction App() {\n  const [messages, setMessages] = useState([]);\n  const [users, dispatchUsers] = useReducer((state, presenceEvent) => {\n    const { action, uuid } = presenceEvent;\n    if (action === 'join' || action === 'state-change' || action === 'here-now') {\n      if (uuid === userId) {\n        // Ignore myself\n        return state;\n      }\n      state[uuid] = {\n        ...state[uuid],\n        id: uuid,\n      };\n      const publicKey = presenceEvent.state ? presenceEvent.state.publicKey : null;\n      if (publicKey) {\n        state[uuid].publicKey = publicKey;\n      }\n      return { ...state };\n    } else if (action === 'leave' || action === 'timeout') {\n      delete state[uuid];\n      return { ...state };\n    }\n    return state;\n  }, {});\n\n  useEffect(() => {\n    const listener = {\n      message: function (m) {\n        const { message } = m;\n        const { messages } = message;\n        console.log('Incoming messages', messages)\n        const newMessages = messages.filter(msg => {\n          console.log('msg.to === userId', msg.to, userId);\n          return msg.user.id !== userId && // Message is not sent from me\n            users[msg.user.id] && // I know the sender\n            msg.to === userId; // Message is sent to me\n        }).map(msg => {\n          const userFrom = users[msg.user.id];\n          const userFromPublicKey = userFrom.publicKey;\n          const { encrypted } = msg;\n          return {\n            ...msg,\n            text: decrypt(userFromPublicKey, encrypted),\n          };\n        })\n\n        setMessages((oldMessages) =>\n          (GiftedChat.append(oldMessages, newMessages)));\n      },\n      presence: function (presenceEvent) {\n        dispatchUsers(presenceEvent);\n      }\n    };\n    pubnub.subscribe({ channels: [channel], withPresence: true });\n    pubnub.addListener(listener);\n\n    // Publish my public key\n    const keyArray = Array.from(keyPair.publicKey)\n    pubnub.setState({\n      channels: [channel],\n      state: {\n        publicKey: keyArray,\n      }\n    });\n\n    pubnub.hereNow({ channels: [channel], includeState: true },\n      (status, response) => {\n        const { occupants } = response.channels[channel];\n        occupants.forEach(user => {\n          dispatchUsers({\n            action: 'here-now',\n            uuid: user.uuid,\n            state: {\n              publicKey: user.state ? user.state.publicKey : null,\n            }\n          });\n        })\n      }\n    );\n    return () => {\n      pubnub.unsubscribe({ channels: [channel] });\n      pubnub.removeListener(listener);\n    };\n  }, []);\n\n  const sendMessage = (newMessages) => {\n    setMessages((oldMessages) =>\n      (GiftedChat.append(oldMessages, newMessages)));\n\n    Object.values(users).forEach(user => {\n      const { publicKey } = user;\n      const messagesToPublish = newMessages.map(message => {\n        const { createdAt, text, id } = message;\n        const encrypted = encrypt(publicKey, text);\n        return {\n          createdAt,\n          user: message.user,\n          encrypted,\n          id,\n          to: user.id\n        }\n      });\n      pubnub.publish({\n        channel: channel,\n        message: {\n          messages: messagesToPublish\n        }\n      });\n    });\n  };\n\n  return (\n    <div className=\"App\" style={styles.container}>\n      <div style={styles.conversationList}>\n        <h2>Participants</h2>\n        {\n          Object.values(users).map(user => {\n            return (\n              <div key={user.id} style={styles.userrec}>\n                <div>\n                  <GiftedAvatar user={{\n                    id: user.id,\n                    avatar: getAvatar(user.id),\n                  }} />\n                </div>\n                <div>{user.id}</div>\n                <div>Public key: {keyToStr(user.publicKey)}</div>\n              </div>\n            )\n          })\n        }\n      </div>\n      <div style={styles.chat}>\n        <GiftedChat\n          messages={messages}\n          onSend={(newMessages) => sendMessage(newMessages)}\n          user={{\n            id: userId,\n            name: userId.toString(),\n            avatar: getAvatar(userId),\n          }}\n        />\n      </div>\n      <div style={styles.converationDetails}>\n        Conversation details\n        </div>\n    </div>\n  )\n};\n\n\nconst styles = {\n  container: {\n    flex: 1,\n    display: \"flex\",\n    flexDirection: \"row\",\n    height: \"100vh\",\n  },\n  conversationList: {\n    display: 'flex',\n    flex: 1,\n    flexDirection: 'column',\n    padding: '12px',\n    overflowY: 'scroll',\n  },\n  chat: {\n    display: \"flex\",\n    flex: 3,\n    flexDirection: \"column\",\n    borderWidth: \"1px\",\n    borderColor: \"#ccc\",\n    borderRightStyle: \"solid\",\n    borderLeftStyle: \"solid\",\n  },\n  converationDetails: {\n    display: 'flex',\n    flex: 1,\n  },\n  userrec: {\n    padding: '8px',\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}